// Code generated by goal-cli. DO NOT EDIT.
// versions:
// 	goal-cli v0.5.24
// 	go       go1.23.2
//
// updated_at: 2024-10-09 00:56:11
// source: pro/user.proto
// 
package models

import (
	"encoding/json"
	"fmt"
	"github.com/goal-web/collection"
	"github.com/goal-web/contracts"
	"github.com/goal-web/database/table"
	user "github.com/goal-web/goal/app/models/user"
	"github.com/goal-web/migration/migrate"
	"github.com/goal-web/supports/logs"
	"github.com/goal-web/supports/utils"
)

var ()

// UserModel
// 用户注释
// @authenticatable
// @timestamps
type UserModel struct {
	Id int64 `json:"id" db:"id;type:BIGINT;not null;primary key"`

	Name string `json:"name" db:"name;type:VARCHAR(255);not null;"`

	Avatar string `json:"avatar" db:"avatar;type:VARCHAR(255);not null;"`
	//@index
	//@goTag:db:"open_id;type:varchar(255);default 'xxasdasdsx'"
	OpenId string `db:"open_id;type:varchar(255);default 'xxasdasdsx'" json:"open_id"`

	WechatInfo *user.WechatInfoData `json:"wechat_info" db:"wechat_info;type:json;not null;"`

	Channel string `json:"channel" db:"channel;type:VARCHAR(255);not null;"`
	//@hidden
	Password string `json:"password" db:"password;type:VARCHAR(255);not null;"`

	CreatedAt string `json:"created_at" db:"created_at;type:timestamp;default CURRENT_TIMESTAMP;"`

	UpdatedAt string `json:"updated_at" db:"updated_at;type:timestamp;DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP;"`

	_raw    contracts.Fields
	_update contracts.Fields
	_append contracts.Fields
	_hidden map[string]struct{}

	_relation_loaded map[contracts.RelationType]struct{}
}

var UserDefine UserStatic

type UserStatic struct {
	TableName        string
	Hidden           []string
	Indexes          []string
	With             []contracts.RelationType
	Appends          map[string]func(model *UserModel) any
	IdGetter         func(model *UserModel, raw int64) int64
	IdSetter         func(model *UserModel, raw int64) int64
	NameGetter       func(model *UserModel, raw string) string
	NameSetter       func(model *UserModel, raw string) string
	AvatarGetter     func(model *UserModel, raw string) string
	AvatarSetter     func(model *UserModel, raw string) string
	OpenIdGetter     func(model *UserModel, raw string) string
	OpenIdSetter     func(model *UserModel, raw string) string
	WechatInfoGetter func(model *UserModel, raw *user.WechatInfoData) *user.WechatInfoData
	WechatInfoSetter func(model *UserModel, raw *user.WechatInfoData) *user.WechatInfoData
	ChannelGetter    func(model *UserModel, raw string) string
	ChannelSetter    func(model *UserModel, raw string) string
	PasswordGetter   func(model *UserModel, raw string) string
	PasswordSetter   func(model *UserModel, raw string) string
	CreatedAtGetter  func(model *UserModel, raw string) string
	CreatedAtSetter  func(model *UserModel, raw string) string
	UpdatedAtGetter  func(model *UserModel, raw string) string
	UpdatedAtSetter  func(model *UserModel, raw string) string

	Saving           func(model *UserModel) contracts.Exception
	Saved            func(model *UserModel)
	Updating         func(model *UserModel, fields contracts.Fields) contracts.Exception
	Updated          func(model *UserModel, fields contracts.Fields)
	Deleting         func(model *UserModel) contracts.Exception
	Deleted          func(model *UserModel)
	PrimaryKeyGetter func(model *UserModel) any
}

func UserMigrator() migrate.Migrator {
	return func(executor contracts.SqlExecutor) contracts.Exception {
		return migrate.Migrate(UserDefine.TableName, UserDefine.Indexes, UserModel{}, executor)
	}
}

func init() {
	UserDefine.TableName = "users"
	UserDefine.Appends = make(map[string]func(model *UserModel) any)
	UserDefine.Hidden = append(
		UserDefine.Hidden,
		"password",
	)
	UserDefine.Indexes = append(
		UserDefine.Indexes,
		"index;open_id_idx;(open_id)",
	)
}

func NewUserModel(fields contracts.Fields) *UserModel {
	var model = UserModel{
		_raw: fields,
	}
	model.Set(fields)
	return &model
}

func UserModelSingleRelationSetter[T any](key contracts.RelationType) func(item *UserModel, value []any) {
	return func(item *UserModel, values []any) {
		var value T
		if len(values) > 0 {
			value = values[0].(T)
		}
		item.Set(contracts.Fields{
			string(key): value,
		})
	}
}
func UserModelMultiRelationSetter[T any](key contracts.RelationType) func(item *UserModel, value []any) {
	return func(model *UserModel, value []any) {
		var results []T
		for _, item := range value {
			results = append(results, item.(T))
		}
		model.Set(contracts.Fields{string(key): results})
	}
}

func UserModelLocalKeyGetter(key string) func(item *UserModel) any {
	return func(item *UserModel) any {
		return item.Get(key)
	}
}

func UserModelRelationGetter[T any](query func() *table.Table[T], foreignKey string) func(keys []any) map[string][]any {
	return func(keys []any) map[string][]any {
		var results = map[string][]any{}
		for key, values := range query().WhereIn(foreignKey, keys).Get().GroupBy(foreignKey) {
			results[key] = collection.New(values).ToAnyArray()
		}
		return results
	}
}

func UserModelThroughRelationGetter[T any](query func() *table.Table[T], midTable, firstKey, secondKey, secondLocalKey string) func(keys []any) map[string][]any {
	return func(keys []any) map[string][]any {
		var results = map[string][]any{}
		groupKey := fmt.Sprintf("%s.%s", midTable, firstKey)
		for key, values := range query().
			AddSelect(fmt.Sprintf("(%s) as _group_key", groupKey)).
			WhereIn(groupKey, keys).
			Join(midTable, fmt.Sprintf("%s.%s", midTable, secondLocalKey), "=", fmt.Sprintf("%s.%s", query().GetTableName(), secondKey)).
			Get().GroupBy("_group_key") {
			results[key] = collection.New(values).ToAnyArray()
		}
		return results
	}
}
func UserQueryWithExecutor(executor contracts.SqlExecutor) *table.Table[UserModel] {
	return UserQuery().SetExecutor(executor)
}

func UserQuery() *table.Table[UserModel] {
	return table.NewQuery(UserDefine.TableName, NewUserModel).
		SetPrimaryKey("id").
		SetCreatedTimeColumn("created_at").
		SetUpdatedTimeColumn("updated_at").
		SetWiths(UserDefine.With...)
}

func (model *UserModel) Hidden(fields ...string) *UserModel {
	for _, field := range fields {
		if model._hidden == nil {
			model._hidden = map[string]struct{}{
				field: struct{}{},
			}
		} else {
			model._hidden[field] = struct{}{}
		}

	}

	return model
}

func (model *UserModel) Exists() bool {
	return UserQuery().Where("id", model.GetPrimaryKey()).Count() > 0
}

func (model *UserModel) Save() contracts.Exception {
	if model._update == nil {
		return nil
	}
	if UserDefine.Saving != nil {
		if err := UserDefine.Saving(model); err != nil {
			return err
		}
	}
	_, err := UserQuery().Where("id", model.GetPrimaryKey()).UpdateE(model._update)
	if err == nil {
		model._update = nil
		if UserDefine.Saved != nil {
			UserDefine.Saved(model)
		}
	}

	return err
}

func (model *UserModel) Set(fields contracts.Fields) {
	for key, value := range fields {

		switch key {
		case "id":
			switch v := value.(type) {
			case int64:
				model.SetId(v)
			case func() int64:
				model.SetId(v())
			case string:
				var vd int64
				err := json.Unmarshal([]byte(v), &vd)
				if err != nil {
					logs.Default().Warn("Failed to Parse field " + key)
					continue
				}
				model.SetId(vd)

			case []byte:
				var vd int64
				err := json.Unmarshal(v, &vd)
				if err != nil {
					logs.Default().Warn("Failed to Parse field " + key)
					continue
				}
				model.SetId(vd)

			}
		case "name":
			switch v := value.(type) {
			case string:
				model.SetName(v)
			case func() string:
				model.SetName(v())
			case []byte:
				model.SetName(string(v))

			}
		case "avatar":
			switch v := value.(type) {
			case string:
				model.SetAvatar(v)
			case func() string:
				model.SetAvatar(v())
			case []byte:
				model.SetAvatar(string(v))

			}
		case "open_id":
			switch v := value.(type) {
			case string:
				model.SetOpenId(v)
			case func() string:
				model.SetOpenId(v())
			case []byte:
				model.SetOpenId(string(v))

			}
		case "wechat_info":
			switch v := value.(type) {
			case *user.WechatInfoData:
				model.SetWechatInfo(v)
			case func() *user.WechatInfoData:
				model.SetWechatInfo(v())
			case string:
				var vd *user.WechatInfoData
				err := json.Unmarshal([]byte(v), &vd)
				if err != nil {
					logs.Default().Warn("Failed to Parse field " + key)
					continue
				}
				model.SetWechatInfo(vd)

			case []byte:
				var vd *user.WechatInfoData
				err := json.Unmarshal(v, &vd)
				if err != nil {
					logs.Default().Warn("Failed to Parse field " + key)
					continue
				}
				model.SetWechatInfo(vd)

			}
		case "channel":
			switch v := value.(type) {
			case string:
				model.SetChannel(v)
			case func() string:
				model.SetChannel(v())
			case []byte:
				model.SetChannel(string(v))

			}
		case "password":
			switch v := value.(type) {
			case string:
				model.SetPassword(v)
			case func() string:
				model.SetPassword(v())
			case []byte:
				model.SetPassword(string(v))

			}
		case "created_at":
			switch v := value.(type) {
			case string:
				model.SetCreatedAt(v)
			case func() string:
				model.SetCreatedAt(v())
			case []byte:
				model.SetCreatedAt(string(v))

			}
		case "updated_at":
			switch v := value.(type) {
			case string:
				model.SetUpdatedAt(v)
			case func() string:
				model.SetUpdatedAt(v())
			case []byte:
				model.SetUpdatedAt(string(v))

			}
		}

	}
}

func (model *UserModel) Only(key ...string) contracts.Fields {
	var fields = make(contracts.Fields)
	for _, k := range key {
		if k == "id" {
			fields[k] = model.GetId()
			continue
		}
		if k == "name" {
			fields[k] = model.GetName()
			continue
		}
		if k == "avatar" {
			fields[k] = model.GetAvatar()
			continue
		}
		if k == "open_id" {
			fields[k] = model.GetOpenId()
			continue
		}
		if k == "wechat_info" {
			fields[k] = model.GetWechatInfo()
			continue
		}
		if k == "channel" {
			fields[k] = model.GetChannel()
			continue
		}
		if k == "password" {
			fields[k] = model.GetPassword()
			continue
		}
		if k == "created_at" {
			fields[k] = model.GetCreatedAt()
			continue
		}
		if k == "updated_at" {
			fields[k] = model.GetUpdatedAt()
			continue
		}

		if UserDefine.Appends[k] != nil {
			fields[k] = UserDefine.Appends[k](model)
		}
	}
	return fields
}

func (model *UserModel) Get(key string) any {
	switch key {
	case "id":
		return model.GetId()
	case "name":
		return model.GetName()
	case "avatar":
		return model.GetAvatar()
	case "open_id":
		return model.GetOpenId()
	case "wechat_info":
		return model.GetWechatInfo()
	case "channel":
		return model.GetChannel()
	case "password":
		return model.GetPassword()
	case "created_at":
		return model.GetCreatedAt()
	case "updated_at":
		return model.GetUpdatedAt()
	}

	if value, exists := model._append[key]; exists {
		return value
	}

	if fn, exists := UserDefine.Appends[key]; exists {
		model._append[key] = fn(model)
		return model._append[key]
	}

	switch contracts.RelationType(key) {
	}

	return nil
}

func (model *UserModel) Except(keys ...string) contracts.Fields {
	var excepts = map[string]struct{}{}
	for _, k := range keys {
		excepts[k] = struct{}{}
	}
	var fields = make(contracts.Fields)
	for key, value := range model.ToFields() {
		if _, ok := excepts[key]; ok {
			continue
		}
		fields[key] = value
	}
	return fields
}

func (model *UserModel) ToFields() contracts.Fields {
	model.Hidden(UserDefine.Hidden...)

	fields := contracts.Fields{}
	if _, exists := model._hidden["id"]; !exists {
		fields["id"] = model.GetId()
	}
	if _, exists := model._hidden["name"]; !exists {
		fields["name"] = model.GetName()
	}
	if _, exists := model._hidden["avatar"]; !exists {
		fields["avatar"] = model.GetAvatar()
	}
	if _, exists := model._hidden["open_id"]; !exists {
		fields["open_id"] = model.GetOpenId()
	}
	if _, exists := model._hidden["wechat_info"]; !exists {
		fields["wechat_info"] = model.GetWechatInfo()
	}
	if _, exists := model._hidden["channel"]; !exists {
		fields["channel"] = model.GetChannel()
	}
	if _, exists := model._hidden["password"]; !exists {
		fields["password"] = model.GetPassword()
	}
	if _, exists := model._hidden["created_at"]; !exists {
		fields["created_at"] = model.GetCreatedAt()
	}
	if _, exists := model._hidden["updated_at"]; !exists {
		fields["updated_at"] = model.GetUpdatedAt()
	}

	for key := range UserDefine.Appends {
		value := model.Get(key)
		if fieldsProvider, ok := value.(contracts.FieldsProvider); ok {
			fields[key] = fieldsProvider.ToFields()
		} else {
			fields[key] = value
		}
	}

	for key := range model._relation_loaded {
		switch key {
		}
	}

	for key, value := range model._raw {
		if _, exists := fields[key]; !exists {
			fields[key] = value
		}
	}

	return fields
}

func (model *UserModel) Update(fields contracts.Fields) contracts.Exception {

	if UserDefine.Updating != nil {
		if err := UserDefine.Updating(model, fields); err != nil {
			return err
		}
	}

	if model._update != nil {
		utils.MergeFields(model._update, fields)
	}

	_, err := UserQuery().Where("id", model.GetPrimaryKey()).UpdateE(fields)

	if err == nil {
		model.Set(fields)
		model._update = nil
		if UserDefine.Updated != nil {
			UserDefine.Updated(model, fields)
		}
	}

	return err
}

func (model *UserModel) Refresh() contracts.Exception {
	fields, err := table.ArrayQuery("users").Where("id", model.GetPrimaryKey()).FirstE()
	if err != nil {
		return err
	}

	model.Set(*fields)
	return nil
}

func (model *UserModel) Delete() contracts.Exception {

	if UserDefine.Deleting != nil {
		if err := UserDefine.Deleting(model); err != nil {
			return err
		}
	}

	_, err := UserQuery().Where("id", model.GetPrimaryKey()).DeleteE()
	if err == nil && UserDefine.Deleted != nil {
		UserDefine.Deleted(model)
	}

	return err
}

func (model *UserModel) GetPrimaryKey() any {
	if UserDefine.PrimaryKeyGetter != nil {
		return UserDefine.PrimaryKeyGetter(model)
	}

	return model.Id
}
func (model *UserModel) GetAuthenticatableKey() string {
	return fmt.Sprintf("%v", model.GetPrimaryKey())
}

func UserAuthProvider(identify string) contracts.Authenticatable {
	return UserQuery().Find(identify)
}

func (model *UserModel) GetId() int64 {
	if UserDefine.IdGetter != nil {
		return UserDefine.IdGetter(model, model.Id)
	}
	return model.Id
}

func (model *UserModel) SetId(value int64) {
	if UserDefine.IdSetter != nil {
		value = UserDefine.IdSetter(model, value)
	}

	if model._update == nil {
		model._update = contracts.Fields{"id": value}
	} else {
		model._update["id"] = value
	}
	model.Id = value
}

func (model *UserModel) GetName() string {
	if UserDefine.NameGetter != nil {
		return UserDefine.NameGetter(model, model.Name)
	}
	return model.Name
}

func (model *UserModel) SetName(value string) {
	if UserDefine.NameSetter != nil {
		value = UserDefine.NameSetter(model, value)
	}

	if model._update == nil {
		model._update = contracts.Fields{"name": value}
	} else {
		model._update["name"] = value
	}
	model.Name = value
}

func (model *UserModel) GetAvatar() string {
	if UserDefine.AvatarGetter != nil {
		return UserDefine.AvatarGetter(model, model.Avatar)
	}
	return model.Avatar
}

func (model *UserModel) SetAvatar(value string) {
	if UserDefine.AvatarSetter != nil {
		value = UserDefine.AvatarSetter(model, value)
	}

	if model._update == nil {
		model._update = contracts.Fields{"avatar": value}
	} else {
		model._update["avatar"] = value
	}
	model.Avatar = value
}

func (model *UserModel) GetOpenId() string {
	if UserDefine.OpenIdGetter != nil {
		return UserDefine.OpenIdGetter(model, model.OpenId)
	}
	return model.OpenId
}

func (model *UserModel) SetOpenId(value string) {
	if UserDefine.OpenIdSetter != nil {
		value = UserDefine.OpenIdSetter(model, value)
	}

	if model._update == nil {
		model._update = contracts.Fields{"open_id": value}
	} else {
		model._update["open_id"] = value
	}
	model.OpenId = value
}

func (model *UserModel) GetWechatInfo() *user.WechatInfoData {
	if UserDefine.WechatInfoGetter != nil {
		return UserDefine.WechatInfoGetter(model, model.WechatInfo)
	}
	return model.WechatInfo
}

func (model *UserModel) SetWechatInfo(value *user.WechatInfoData) {
	if UserDefine.WechatInfoSetter != nil {
		value = UserDefine.WechatInfoSetter(model, value)
	}

	if model._update == nil {
		model._update = contracts.Fields{"wechat_info": value}
	} else {
		model._update["wechat_info"] = value
	}
	model.WechatInfo = value
}

func (model *UserModel) GetChannel() string {
	if UserDefine.ChannelGetter != nil {
		return UserDefine.ChannelGetter(model, model.Channel)
	}
	return model.Channel
}

func (model *UserModel) SetChannel(value string) {
	if UserDefine.ChannelSetter != nil {
		value = UserDefine.ChannelSetter(model, value)
	}

	if model._update == nil {
		model._update = contracts.Fields{"channel": value}
	} else {
		model._update["channel"] = value
	}
	model.Channel = value
}

func (model *UserModel) GetPassword() string {
	if UserDefine.PasswordGetter != nil {
		return UserDefine.PasswordGetter(model, model.Password)
	}
	return model.Password
}

func (model *UserModel) SetPassword(value string) {
	if UserDefine.PasswordSetter != nil {
		value = UserDefine.PasswordSetter(model, value)
	}

	if model._update == nil {
		model._update = contracts.Fields{"password": value}
	} else {
		model._update["password"] = value
	}
	model.Password = value
}

func (model *UserModel) GetCreatedAt() string {
	if UserDefine.CreatedAtGetter != nil {
		return UserDefine.CreatedAtGetter(model, model.CreatedAt)
	}
	return model.CreatedAt
}

func (model *UserModel) SetCreatedAt(value string) {
	if UserDefine.CreatedAtSetter != nil {
		value = UserDefine.CreatedAtSetter(model, value)
	}

	if model._update == nil {
		model._update = contracts.Fields{"created_at": value}
	} else {
		model._update["created_at"] = value
	}
	model.CreatedAt = value
}

func (model *UserModel) GetUpdatedAt() string {
	if UserDefine.UpdatedAtGetter != nil {
		return UserDefine.UpdatedAtGetter(model, model.UpdatedAt)
	}
	return model.UpdatedAt
}

func (model *UserModel) SetUpdatedAt(value string) {
	if UserDefine.UpdatedAtSetter != nil {
		value = UserDefine.UpdatedAtSetter(model, value)
	}

	if model._update == nil {
		model._update = contracts.Fields{"updated_at": value}
	} else {
		model._update["updated_at"] = value
	}
	model.UpdatedAt = value
}
