// Code generated by goal-cli. DO NOT EDIT.
// versions:
// 	goal-cli v0.5.24
// 	go       go1.23.2
//
// updated_at: 2024-10-09 19:07:27
// source: pro/Article.proto
// 
package models

import (
	"encoding/json"
	"fmt"
	"github.com/goal-web/collection"
	"github.com/goal-web/contracts"
	"github.com/goal-web/database/table"
	"github.com/goal-web/migration/migrate"
	"github.com/goal-web/supports/logs"
	"github.com/goal-web/supports/utils"
)

var ()

// ArticleModel
// @timestamps
type ArticleModel struct {
	Id uint32 `json:"id" db:"id;type:INT UNSIGNED;not null;primary key;AUTO_INCREMENT;"`

	Title string `json:"title" db:"title;type:VARCHAR(255);not null;"`

	CreatedAt string `json:"created_at" db:"created_at;type:timestamp;default CURRENT_TIMESTAMP;"`

	UpdatedAt string `json:"updated_at" db:"updated_at;type:timestamp;DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP;"`

	_raw    contracts.Fields
	_update contracts.Fields
	_append contracts.Fields
	_hidden map[string]struct{}

	_relation_loaded map[contracts.RelationType]struct{}
}

var ArticleDefine ArticleStatic

type ArticleStatic struct {
	TableName       string
	Hidden          []string
	Indexes         []string
	With            []contracts.RelationType
	Appends         map[string]func(model *ArticleModel) any
	IdGetter        func(model *ArticleModel, raw uint32) uint32
	IdSetter        func(model *ArticleModel, raw uint32) uint32
	TitleGetter     func(model *ArticleModel, raw string) string
	TitleSetter     func(model *ArticleModel, raw string) string
	CreatedAtGetter func(model *ArticleModel, raw string) string
	CreatedAtSetter func(model *ArticleModel, raw string) string
	UpdatedAtGetter func(model *ArticleModel, raw string) string
	UpdatedAtSetter func(model *ArticleModel, raw string) string

	Saving           func(model *ArticleModel) contracts.Exception
	Saved            func(model *ArticleModel)
	Updating         func(model *ArticleModel, fields contracts.Fields) contracts.Exception
	Updated          func(model *ArticleModel, fields contracts.Fields)
	Deleting         func(model *ArticleModel) contracts.Exception
	Deleted          func(model *ArticleModel)
	PrimaryKeyGetter func(model *ArticleModel) any
}

func ArticleMigrator() migrate.Migrator {
	return func(executor contracts.SqlExecutor) contracts.Exception {
		return migrate.Migrate(ArticleDefine.TableName, ArticleDefine.Indexes, ArticleModel{}, executor)
	}
}

func init() {
	ArticleDefine.TableName = "articles"
	ArticleDefine.Appends = make(map[string]func(model *ArticleModel) any)
}

func NewArticleModel(fields contracts.Fields) *ArticleModel {
	var model = ArticleModel{
		_raw: fields,
	}
	model.Set(fields)
	return &model
}

func ArticleModelSingleRelationSetter[T any](key contracts.RelationType) func(item *ArticleModel, value []any) {
	return func(item *ArticleModel, values []any) {
		var value T
		if len(values) > 0 {
			value = values[0].(T)
		}
		item.Set(contracts.Fields{
			string(key): value,
		})
	}
}
func ArticleModelMultiRelationSetter[T any](key contracts.RelationType) func(item *ArticleModel, value []any) {
	return func(model *ArticleModel, value []any) {
		var results []T
		for _, item := range value {
			results = append(results, item.(T))
		}
		model.Set(contracts.Fields{string(key): results})
	}
}

func ArticleModelLocalKeyGetter(key string) func(item *ArticleModel) any {
	return func(item *ArticleModel) any {
		return item.Get(key)
	}
}

func ArticleModelRelationGetter[T any](query func() *table.Table[T], foreignKey string) func(keys []any) map[string][]any {
	return func(keys []any) map[string][]any {
		var results = map[string][]any{}
		for key, values := range query().WhereIn(foreignKey, keys).Get().GroupBy(foreignKey) {
			results[key] = collection.New(values).ToAnyArray()
		}
		return results
	}
}

func ArticleModelThroughRelationGetter[T any](query func() *table.Table[T], midTable, firstKey, secondKey, secondLocalKey string) func(keys []any) map[string][]any {
	return func(keys []any) map[string][]any {
		var results = map[string][]any{}
		groupKey := fmt.Sprintf("%s.%s", midTable, firstKey)
		for key, values := range query().
			AddSelect(fmt.Sprintf("(%s) as _group_key", groupKey)).
			WhereIn(groupKey, keys).
			Join(midTable, fmt.Sprintf("%s.%s", midTable, secondLocalKey), "=", fmt.Sprintf("%s.%s", query().GetTableName(), secondKey)).
			Get().GroupBy("_group_key") {
			results[key] = collection.New(values).ToAnyArray()
		}
		return results
	}
}
func ArticleQueryWithExecutor(executor contracts.SqlExecutor) *table.Table[ArticleModel] {
	return ArticleQuery().SetExecutor(executor)
}

func ArticleQuery() *table.Table[ArticleModel] {
	return table.NewQuery(ArticleDefine.TableName, NewArticleModel).
		SetPrimaryKey("id").
		SetCreatedTimeColumn("created_at").
		SetUpdatedTimeColumn("updated_at").
		SetWiths(ArticleDefine.With...)
}

func (model *ArticleModel) Hidden(fields ...string) *ArticleModel {
	for _, field := range fields {
		if model._hidden == nil {
			model._hidden = map[string]struct{}{
				field: struct{}{},
			}
		} else {
			model._hidden[field] = struct{}{}
		}

	}

	return model
}

func (model *ArticleModel) Exists() bool {
	return ArticleQuery().Where("id", model.GetPrimaryKey()).Count() > 0
}

func (model *ArticleModel) Save() contracts.Exception {
	if model._update == nil {
		return nil
	}
	if ArticleDefine.Saving != nil {
		if err := ArticleDefine.Saving(model); err != nil {
			return err
		}
	}
	_, err := ArticleQuery().Where("id", model.GetPrimaryKey()).UpdateE(model._update)
	if err == nil {
		model._update = nil
		if ArticleDefine.Saved != nil {
			ArticleDefine.Saved(model)
		}
	}

	return err
}

func (model *ArticleModel) Set(fields contracts.Fields) {
	for key, value := range fields {

		switch key {
		case "id":
			switch v := value.(type) {
			case uint32:
				model.SetId(v)
			case func() uint32:
				model.SetId(v())
			case string:
				var vd uint32
				err := json.Unmarshal([]byte(v), &vd)
				if err != nil {
					logs.Default().Warn("Failed to Parse field " + key)
					continue
				}
				model.SetId(vd)

			case []byte:
				var vd uint32
				err := json.Unmarshal(v, &vd)
				if err != nil {
					logs.Default().Warn("Failed to Parse field " + key)
					continue
				}
				model.SetId(vd)

			}
		case "title":
			switch v := value.(type) {
			case string:
				model.SetTitle(v)
			case func() string:
				model.SetTitle(v())
			case []byte:
				model.SetTitle(string(v))

			}
		case "created_at":
			switch v := value.(type) {
			case string:
				model.SetCreatedAt(v)
			case func() string:
				model.SetCreatedAt(v())
			case []byte:
				model.SetCreatedAt(string(v))

			}
		case "updated_at":
			switch v := value.(type) {
			case string:
				model.SetUpdatedAt(v)
			case func() string:
				model.SetUpdatedAt(v())
			case []byte:
				model.SetUpdatedAt(string(v))

			}
		}

	}
}

func (model *ArticleModel) Only(key ...string) contracts.Fields {
	var fields = make(contracts.Fields)
	for _, k := range key {
		if k == "id" {
			fields[k] = model.GetId()
			continue
		}
		if k == "title" {
			fields[k] = model.GetTitle()
			continue
		}
		if k == "created_at" {
			fields[k] = model.GetCreatedAt()
			continue
		}
		if k == "updated_at" {
			fields[k] = model.GetUpdatedAt()
			continue
		}

		if ArticleDefine.Appends[k] != nil {
			fields[k] = ArticleDefine.Appends[k](model)
		}
	}
	return fields
}

func (model *ArticleModel) Get(key string) any {
	switch key {
	case "id":
		return model.GetId()
	case "title":
		return model.GetTitle()
	case "created_at":
		return model.GetCreatedAt()
	case "updated_at":
		return model.GetUpdatedAt()
	}

	if value, exists := model._append[key]; exists {
		return value
	}

	if fn, exists := ArticleDefine.Appends[key]; exists {
		model._append[key] = fn(model)
		return model._append[key]
	}

	switch contracts.RelationType(key) {
	}

	return nil
}

func (model *ArticleModel) Except(keys ...string) contracts.Fields {
	var excepts = map[string]struct{}{}
	for _, k := range keys {
		excepts[k] = struct{}{}
	}
	var fields = make(contracts.Fields)
	for key, value := range model.ToFields() {
		if _, ok := excepts[key]; ok {
			continue
		}
		fields[key] = value
	}
	return fields
}

func (model *ArticleModel) ToFields() contracts.Fields {
	model.Hidden(ArticleDefine.Hidden...)

	fields := contracts.Fields{}
	if _, exists := model._hidden["id"]; !exists {
		fields["id"] = model.GetId()
	}
	if _, exists := model._hidden["title"]; !exists {
		fields["title"] = model.GetTitle()
	}
	if _, exists := model._hidden["created_at"]; !exists {
		fields["created_at"] = model.GetCreatedAt()
	}
	if _, exists := model._hidden["updated_at"]; !exists {
		fields["updated_at"] = model.GetUpdatedAt()
	}

	for key := range ArticleDefine.Appends {
		value := model.Get(key)
		if fieldsProvider, ok := value.(contracts.FieldsProvider); ok {
			fields[key] = fieldsProvider.ToFields()
		} else {
			fields[key] = value
		}
	}

	for key := range model._relation_loaded {
		switch key {
		}
	}

	for key, value := range model._raw {
		if _, exists := fields[key]; !exists {
			fields[key] = value
		}
	}

	return fields
}

func (model *ArticleModel) Update(fields contracts.Fields) contracts.Exception {

	if ArticleDefine.Updating != nil {
		if err := ArticleDefine.Updating(model, fields); err != nil {
			return err
		}
	}

	if model._update != nil {
		utils.MergeFields(model._update, fields)
	}

	_, err := ArticleQuery().Where("id", model.GetPrimaryKey()).UpdateE(fields)

	if err == nil {
		model.Set(fields)
		model._update = nil
		if ArticleDefine.Updated != nil {
			ArticleDefine.Updated(model, fields)
		}
	}

	return err
}

func (model *ArticleModel) Refresh() contracts.Exception {
	fields, err := table.ArrayQuery("articles").Where("id", model.GetPrimaryKey()).FirstE()
	if err != nil {
		return err
	}

	model.Set(*fields)
	return nil
}

func (model *ArticleModel) Delete() contracts.Exception {

	if ArticleDefine.Deleting != nil {
		if err := ArticleDefine.Deleting(model); err != nil {
			return err
		}
	}

	_, err := ArticleQuery().Where("id", model.GetPrimaryKey()).DeleteE()
	if err == nil && ArticleDefine.Deleted != nil {
		ArticleDefine.Deleted(model)
	}

	return err
}

func (model *ArticleModel) GetPrimaryKey() any {
	if ArticleDefine.PrimaryKeyGetter != nil {
		return ArticleDefine.PrimaryKeyGetter(model)
	}

	return model.Id
}

func (model *ArticleModel) GetId() uint32 {
	if ArticleDefine.IdGetter != nil {
		return ArticleDefine.IdGetter(model, model.Id)
	}
	return model.Id
}

func (model *ArticleModel) SetId(value uint32) {
	if ArticleDefine.IdSetter != nil {
		value = ArticleDefine.IdSetter(model, value)
	}

	if model._update == nil {
		model._update = contracts.Fields{"id": value}
	} else {
		model._update["id"] = value
	}
	model.Id = value
}

func (model *ArticleModel) GetTitle() string {
	if ArticleDefine.TitleGetter != nil {
		return ArticleDefine.TitleGetter(model, model.Title)
	}
	return model.Title
}

func (model *ArticleModel) SetTitle(value string) {
	if ArticleDefine.TitleSetter != nil {
		value = ArticleDefine.TitleSetter(model, value)
	}

	if model._update == nil {
		model._update = contracts.Fields{"title": value}
	} else {
		model._update["title"] = value
	}
	model.Title = value
}

func (model *ArticleModel) GetCreatedAt() string {
	if ArticleDefine.CreatedAtGetter != nil {
		return ArticleDefine.CreatedAtGetter(model, model.CreatedAt)
	}
	return model.CreatedAt
}

func (model *ArticleModel) SetCreatedAt(value string) {
	if ArticleDefine.CreatedAtSetter != nil {
		value = ArticleDefine.CreatedAtSetter(model, value)
	}

	if model._update == nil {
		model._update = contracts.Fields{"created_at": value}
	} else {
		model._update["created_at"] = value
	}
	model.CreatedAt = value
}

func (model *ArticleModel) GetUpdatedAt() string {
	if ArticleDefine.UpdatedAtGetter != nil {
		return ArticleDefine.UpdatedAtGetter(model, model.UpdatedAt)
	}
	return model.UpdatedAt
}

func (model *ArticleModel) SetUpdatedAt(value string) {
	if ArticleDefine.UpdatedAtSetter != nil {
		value = ArticleDefine.UpdatedAtSetter(model, value)
	}

	if model._update == nil {
		model._update = contracts.Fields{"updated_at": value}
	} else {
		model._update["updated_at"] = value
	}
	model.UpdatedAt = value
}
